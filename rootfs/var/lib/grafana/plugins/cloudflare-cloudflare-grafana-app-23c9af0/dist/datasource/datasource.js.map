{"version":3,"sources":["../../src/datasource/datasource.js"],"names":["metricList","dimensionList","unitList","dimensionValues","_","TableModel","CloudflareDatasource","instanceSettings","templateSrv","dashboardSrv","proxySrv","name","api","value","variable","multi","includeAll","join","options","targets","length","Promise","resolve","data","target","metrics","filters","getAdhocFilters","tag","replace","scopedVars","joinField","bind","union","query","range","from","to","dimensions","bytime","panel","dash","getPanelInfoById","panelId","type","fetchTag","then","fetchData","processResponse","response","resp","reject","message","errors","result","rows","time_intervals","processTableData","processTimeSeries","seriesList","intervals","map","ts","Date","parse","forEach","group","series","m","seriesName","unit","Math","min","grafana_series","datapoints","point","i","transform","push","table","columns","text","e","row","fetchClusters","fetchOrganizations","fetchZones","keys","key"],"mappings":"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","file":"datasource.js","sourcesContent":["import {metricList, dimensionList, unitList, dimensionValues} from './metric_def';\nimport _ from 'lodash';\nimport TableModel from 'app/core/table_model';\nimport './cfapi';\n\nclass CloudflareDatasource {\n\n  constructor(instanceSettings, templateSrv, dashboardSrv, proxySrv)  {\n    this.instanceSettings = instanceSettings;\n    this.name = instanceSettings.name;\n    this.templateSrv = templateSrv;\n    this.dashboardSrv = dashboardSrv;\n    this.api = proxySrv;\n  }\n\n  joinField(value, variable) {\n    if (!variable.multi && !variable.includeAll) {\n      return value;\n    }\n    if (typeof value === 'string') {\n      return value;\n    }\n    return value.join(',');\n  }\n\n  query(options) {\n    if (!options.targets || options.targets.length === 0) {\n      return Promise.resolve({data: []});\n    }\n\n    /* Do not run queries if there's not metric selected */\n    let target = options.targets[0];\n    if (!target.metrics || target.metrics.length === 0) {\n      return Promise.resolve({data: []});\n    }\n\n    /* Build out ad-hoc filters and do templating. */\n    let filters = this.templateSrv.getAdhocFilters(this.name);\n    let tag = this.templateSrv.replace(target.tag, options.scopedVars, this.joinField.bind(this));\n    if (!tag) {\n      return Promise.resolve({data: []});\n    }\n\n    /* Combine filters */\n    filters = _.union(filters, target.filters);\n\n    /* Run the query and process response */\n    let query = {\n      range: {\n        from: options.range.from,\n        to: options.range.to\n      },\n      tag: tag,\n      from: target.from || 'zone',\n      metrics: target.metrics,\n      dimensions: target.dimensions,\n      filters: filters,\n      bytime: true\n    };\n\n    let panel = this.dashboardSrv.dash.getPanelInfoById(options.panelId);\n    if (panel) {\n      query.bytime = (panel.panel.type != 'table');\n    }\n\n    /* Resolve tag, and fetch data */\n    return this.api.fetchTag(query).then(tag => {\n      return this.api.fetchData(query).then(response => {\n        return this.processResponse(query, options, response);\n      });\n    });\n  }\n\n  processResponse(query, options, resp, bytime) {\n    /* Check whether the API response is OK and well formed. */\n    let data = resp['data'];\n    if (!data) {\n      return Promise.reject({message: 'No data in the API response.'});\n    }\n    if (data.errors.length > 0) {\n      return Promise.reject({message: data.errors.join(' ')});\n    }\n\n    var result = data.result;\n    if (result.rows === 0) {\n      return [];\n    }\n\n    /* Check whether the result is a time series or table */\n    if (!result.time_intervals) {\n      return this.processTableData(result);\n    } else {\n      return this.processTimeSeries(result);\n    }\n  }\n\n  processTimeSeries(result) {\n    let seriesList = [];\n    let data = result.data;\n    let intervals = result.time_intervals.map(ts => {\n      return ts.map(Date.parse);\n    });\n    data.forEach(group => {\n      group.metrics.forEach((series, m) => {\n        /* Generate time series for each metric */\n        let seriesName = result.query.metrics[m]\n        /* Get time unit for metric */\n        let unit = unitList[seriesName];\n        /* Add dimension value if present */\n        if (group.dimensions) {\n          let dimensions = group.dimensions.join(\",\")\n          if (dimensions == \"\") {\n            return;\n          }\n          seriesName += \", \" + dimensions;\n        }\n        /* Truncate series to time interval length and vice versa */\n        series.length = Math.min(series.length, intervals.length);\n        /* Format the time series */\n        let grafana_series = {\n          target: seriesName,\n          datapoints: series.map((point, i) => {\n            let ts = intervals[i];\n            if (unit) {\n              point = unit.transform(point, ts[0], ts[1]);\n            }\n            return [point, ts[1]];\n          })\n        };\n        seriesList.push(grafana_series);\n      });\n    });\n\n    return { data: seriesList };\n  }\n\n  processTableData(result) {\n    let table = new TableModel();\n    /* Create table columns */\n    result.query.dimensions.forEach(e => {\n      table.columns.push({text: e});\n    });\n    result.query.metrics.forEach(e => {\n      table.columns.push({text: e});\n    });\n    /* Add rows */\n    result.data.forEach(group => {\n      let row = [];\n      group.dimensions.forEach(e => {\n        row.push(e)\n      });\n      group.metrics.forEach(e => {\n        row.push(e)\n      });\n      table.rows.push(row);\n    });\n    return {data: [table]};\n  }\n\n  metricFindQuery(query) {\n    if (query === 'metrics()') {\n      return Promise.resolve(metricList);\n    }\n    if (query === 'dimensions()') {\n      return Promise.resolve(dimensionList);\n    }\n    if (query === 'clusters()') {\n      return this.api.fetchClusters();\n    }\n    if (query === 'organizations()') {\n      return this.api.fetchOrganizations();\n    }\n    return this.api.fetchZones();\n  }\n\n  getTagKeys() {\n    return Promise.resolve(dimensionList.map(e => {\n      return {text: e.value};\n    }));\n  }\n\n  getTagValues(options) {\n    let keys = dimensionValues[options.key] || [];\n    return Promise.resolve(keys.map(e => {\n      return {text: e};\n    }));\n  }\n}\n\nexport {CloudflareDatasource};"]}